<!doctype html>
<html>
<head>
	<script type="text/javascript">
	// if Facebook redirect hash is present remove it: https://stackoverflow.com/questions/7131909/facebook-callback-appends-to-return-url
	if (window.location.hash && window.location.hash == '#_=_') {
		if (window.history && history.pushState) {
			window.history.pushState("", document.title, window.location.pathname);
		} else {
			window.location.hash = '';
		}
	}
	</script>
	<title>Concarneau</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
	<link rel="apple-touch-icon" href="/content/images/tiles/base-game/RCr.png">
	<link rel="apple-touch-startup-image" href="/content/images/ui/bg.jpg">
	<link rel="shortcut icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="/content/css/bootstrap.3.0.2.min.css" type='text/css'>
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" type='text/css'>
	<link rel="stylesheet" href="/content/css/game.css" type='text/css'>
</head>
<body>
<input type="checkbox" id="menu-checkbox" checked />
<input type="checkbox" id="collapsible-menu-checkbox-outer" <%- user.collapsible_menu ? 'checked="true"' : '' %> />
<input type="checkbox" id="dark-mode-checkbox-outer" <%- user.dark_mode ? 'checked="true"' : '' %> />
<div id="wrapper">
<label id="menu-open" for="menu-checkbox" onclick="openMenu()">
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
</label>
<label id="menu-close" for="menu-checkbox" class="hidden">
	<svg class="fa-times"><use xlink:href="#fa-times"></use></svg>
</label>
<label id="menu-overlay" for="menu-checkbox"></label>
<div id="menus">
	<div id="game-menu">
		<span class="menu-header">GAMES <svg class="fa-edit" onclick="enableGamesEdit(evt || event)"><use xlink:href="#fa-edit"></use></svg><svg class="fa-plus-square-o"><use xlink:href="#fa-plus-square-o"></use></svg></span>
		<div id="list-games">
			<div id="active-games">
				<div class="menu-sub-header">Your move:</div>
			</div>
			<div id="inactive-games">
				<div class="menu-sub-header">Waiting on move:</div>
			</div>
			<div id="finished-games">
				<div class="menu-sub-header">Finished:</div>
			</div>
		</div>
		<!--<div>
			<input type="checkbox" id="test-complete" />
		</div>-->
	</div>
	<div id="friends-menu">
		<span class="menu-header">FRIENDS <svg class="fa-edit hidden" onclick="enableFriendsEdit(event)"><use xlink:href="#fa-edit"></use></svg></span>
		<div id="username-info">You: <svg class="fa-user"><use xlink:href="#fa-user"></use></svg><%- user.username %></div>
		<form id="add-friend-form">
			<div class="input-group">
				<input type="text" class="form-control" id="add-friend-input" placeholder="Username" autocomplete="off">
				<span class="input-group-btn">
					<button class="btn btn-default" type="submit">Add</button>
				</span>
			</div>
		</form>
		<div id="username-alert" class="alert">Placeholder text</div>
		<div id="friends-list"></div>
	</div>
	<div id="settings-menu">
		<span class="menu-header">SETTINGS</span>
		<a href="/profile">Profile</a>
		<div class="checkbox">
			<label>
				<input type="checkbox"
					   onclick="socket.emit('email notification', this.checked)"
					   <%- user.email_notifications ? 'checked="true"' : '' %>
					   <%- !(user.facebook.email || user.google.email || user.local.email) ? 'disabled' : '' %>> E-mail notifications
			</label>
			<%- !(user.facebook.email || user.google.email || user.local.email) ? '(requires non-Twitter login linked in Profile)' : '' %>
		</div>
		<div class="checkbox">
			<label>
				<input type="checkbox"
					   onclick="socket.emit('twitter notification', this.checked)"
					   <%- user.twitter_notifications ? 'checked="true"' : '' %>
					   <%- !user.twitter.username ? 'disabled' : '' %>> Twitter notifications
			</label>
			<%- !user.twitter.username ? '(requires Twitter login linked in Profile)' : '' %>
		</div>
		<div class="checkbox">
			<label>
				<input id="sound-notifications-checkbox"
				       type="checkbox"
					   onclick="socket.emit('sound notification', this.checked);  if(this.checked) { var bell = new Audio('/content/sounds/church-bell.mp3'); bell.volume = 0; bell.play(); }"
					   <%- user.sound_notifications ? 'checked="true"' : '' %>> Sound notifications
			</label>
		</div>
		<div class="checkbox">
			<label>
				<input id="collapsible-menu-checkbox"
				       type="checkbox"
					   onclick="socket.emit('collapsible menu', this.checked); if(this.checked) { $('#collapsible-menu-checkbox-outer').prop('checked', true); } else { $('#collapsible-menu-checkbox-outer').prop('checked', false); }"
					   <%- user.collapsible_menu ? 'checked="true"' : '' %>> Always collapse menu
			</label>
		</div>
		<div class="checkbox">
			<label>
				<input id="dark-mode-checkbox"
				       type="checkbox"
					   onclick="socket.emit('dark mode', this.checked); if(this.checked) { $('#dark-mode-checkbox-outer').prop('checked', true); } else { $('#dark-mode-checkbox-outer').prop('checked', false); }"
					   <%- user.dark_mode ? 'checked="true"' : '' %>> Dark mode
			</label>
		</div>
		<div class="dropdown">
			<label for="preferred-color-select">Preferred color:</label>
			<select id="preferred-color-select" class="form-control"
			        onchange="socket.emit('preferred color', this.value)">
			    <option value="none"   <%- !user.preferred_color || user.preferred_color === 'none'  ? 'selected' : '' %>>No preference</option>
			    <option value="green"  <%- user.preferred_color === 'green'  ? 'selected' : '' %>>Green</option>
			    <option value="gray"   <%- user.preferred_color === 'gray'   ? 'selected' : '' %>>Gray</option>
			    <option value="blue"   <%- user.preferred_color === 'blue'   ? 'selected' : '' %>>Blue</option>
			    <option value="red"    <%- user.preferred_color === 'red'    ? 'selected' : '' %>>Red</option>
			    <option value="yellow" <%- user.preferred_color === 'yellow' ? 'selected' : '' %>>Yellow</option>
			    <option value="purple" <%- user.preferred_color === 'purple' ? 'selected' : '' %>>Purple</option>
			</select>
		</div>
		<a href="/logout">Logout</a>
	</div>
</div>
<div id="menu-selection">
	<div id="game-menu-selection" class="iconmelon menu-selected" onclick="menuClick('#game-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-templates"></use>
		</svg>
	</div>
	<div id="friends-menu-selection" class="iconmelon" onclick="menuClick('#friends-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-environment"></use>
		</svg>
	</div>
	<div id="settings-menu-selection" class="iconmelon" onclick="menuClick('#settings-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-settings"></use>
		</svg>
	</div>
</div>
<div id="author-info">
	<div>
		Created by <span id="author-name">Brian Ouellette</span>
		<a href="http://github.com/btouellette/concarneau"><svg class="fa-github"><use xlink:href="#fa-github"></use></svg></a>
	</div>
	<div>
		<span>Buy me a beer?</span>
		<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
			<input type="hidden" name="cmd" value="_donations">
			<input type="hidden" name="business" value="btouellette@gmail.com">
			<input type="hidden" name="lc" value="US">
			<input type="hidden" name="item_name" value="Concarneau">
			<input type="hidden" name="no_note" value="0">
			<input type="hidden" name="currency_code" value="USD">
			<input type="hidden" name="bn" value="PP-DonationsBF:paypal-icon.png:NonHostedGuest">
			<input type="image" height="25" width="25" src="/content/images/ui/paypal_logo.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
		</form>
		<img id="btc-donate" height="25" width="25" src="/content/images/ui/bitcoin_logo.png" />
	</div>
	<div>
		<span>Buy the game?</span>
		<a href="http://amzn.to/1pd6fg3"><img id="amazon-link" height="25" width="25" src="/content/images/ui/amazon_logo.png" /></a>
	</div>

</div>
<div id="svg-wrapper">
	<svg id="game-svg" width="100%" height="100%">
		<defs>
			<pattern id="thin-stripes-pattern" width="5" height="5" patternUnits="userSpaceOnUse">
				<rect width="5" height="5"></rect>
				<path d="M0 5L5 0ZM6 4L4 6ZM-1 1L1 -1Z"></path>
			</pattern>
		</defs>
		<rect width="100%" height="100%" fill="url(#thin-stripes-pattern)" id="game-background"></rect>
	</svg>
</div>
<div id="chat-wrapper" class="panel panel-primary hidden">
	<div id="chat-header" class="panel-heading">
		<div id="chat-header-label"><svg class="fa-comments" fill="white"><use xlink:href="#fa-comments"></use></svg><span> Chat</span></div>
		<div id="chat-toggle" class="btn-group">
			<a class="btn btn-default btn-xs" onclick="$('#chat-body,#chat-footer').toggle()">
				<svg class="fa-chevron-down"><use xlink:href="#fa-chevron-down"></use></svg>
			</a>
		</div>
	</div>
	<div id="chat-body">
		<ul id="chat-message-list">
		</ul>
	</div>
	<div id="chat-footer">
		<form id="chat-message-form">
			<div class="input-group">
				<input id="chat-message-input" type="text" class="form-control input-sm" autocomplete="off" maxlength="200" placeholder="Type your message here...">
				<span class="input-group-btn">
					<button class="btn btn-sm btn-info" type="submit">Send</button>
				</span>
			</div>
		</form>
	</div>
</div>
</div>
<script src="/content/js/standalone.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.8/d3.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
<script>
//TODO: show socket status on page
//TODO: show player online status
//TODO: show player avatars (gravatars?)
//TODO: Modernizr and noscript redirects
//TODO: move these variables out of the global namespace (add onclick to elements via JS)
//TODO: zoom and pan when active tile moves if out of zoom/pan range
//TODO: default zoom level should be dependendent on number of placed tiles
//TODO: see if there is a way to prevent the image rerender across the board when the active tile is scaled
//TODO: add keyboard shortcuts ENTER = place tile, arrows = pan
//TODO: concede button
//TODO: list points on the board
//TODO: activatable overlay showing count of tiles that could fit in a space
//TODO: add welcome popup explaining buttons and linking to rules if 0 games and 0 friends, allow to view again from settings
//TODO: scoreboard/game record
//TODO: You win! or You lost! alert when game is finished (with rematch button)
//TODO: if there is a choice about which meeple to exchange from tower captures prompt the user to choose and populate meeple.tower.capture.exchangeType
//TODO: keep win/loss stats
//TODO: add a message to the game chat when a tile is discarded

var userGames = <%- JSON.stringify(user.activeGames) %>;
// sort user's games most to least recent
userGames.sort(function(a,b) { return (a.lastModified < b.lastModified) ? 1 : ((b.lastModified < a.lastModified) ? -1 : 0); });

var userFriends = <%- JSON.stringify(user.friends) %>;
var userID = '<%- user._id %>';

var socket = io('<%- process.env.SERVER_URL %>');

var currentGameID, selectedMove, svgHeight, svgWidth;
var meeplePlacementMode = 'normal';
var reverseScale = 1;
var reverseTranslation = [0,0];
var transitionDuration = 750;
var tileSize = 100;

function menuClick(menuToOpen, button) {
	$('#menus > div').hide();
	$('#menu-selection > div').removeClass('menu-selected');
	$(menuToOpen).show();
	$(button).addClass('menu-selected');
}

function openMenu() {
	$("#menu-close").removeClass('hidden');
}

function enableFriendsEdit(e) {
	$('#friends-list .fa-user').attr('class','fa-user hidden');
	$('#friends-list .fa-trash-o').attr('class','fa-trash-o').css('cursor', 'pointer').on('click', function () {
		socket.emit('remove friend', this.parentNode.id.substr(7));
		$(this.parentNode).remove();
		if($('.friend-listing').length === 0) {
			$('#friends-menu .fa-edit').attr('class','fa-edit hidden');
		}
	});
	$(window).on('click.friend-edit', function() {
		disableFriendsEdit();
	});
	e.stopPropagation();
}

function disableFriendsEdit() {
	$('#friends-list .fa-trash-o').attr('class','fa-trash-o hidden');
	$('#friends-list .fa-user').attr('class','fa-user');
	$(window).off('click.friend-edit');
}

function enableGamesEdit(e) {
	$('#game-menu .tile-count').hide();
	// remove hidden element from trash icons
	$('#game-menu .fa-trash-o').attr('class','fa-trash-o').on('click', function () {
		var gameID = this.parentNode.parentNode.id.substr(5);
		socket.emit('remove game', gameID);
		$(this.parentNode.parentNode).remove();
		// if we deleted the game we are viewing remove relevant svg elements
		if(gameID === currentGameID) {
			resetActiveTile(false);
			$('#placed-tile-images,#placed-tile-pieces,#turn-markers,#valid-placements,#meeple-placements').empty();
			$('#active-tile-image').remove();
			$('.score-group').remove();
			$('#score-bg').attr('opacity', 0);
		}
		// if there are no more games hide the edit/delete button
		if($('.menu-game-listing').length === 0) {
			$('#game-menu .fa-edit').attr('class','fa-edit hidden');
		}
	});
	$(window).on('click.games-edit', function() {
		disableGamesEdit();
	});
	e.stopPropagation();
}

function disableGamesEdit() {
	$('#game-menu .fa-trash-o').attr('class','fa-trash-o hidden').off('click');
	$('#game-menu .tile-count').show();
	$(window).off('click.games-edit');
}

(function ($) {
	// debouncedresize: special jQuery event that happens once after a window resize
	// https://github.com/louisremi/jquery-smartresize
	// Copyright 2012 @louis_remi
	// Licensed under the MIT license.
	var $event = $.event,
		$special,
		resizeTimeout;
	$special = $event.special.debouncedresize = {
		setup: function () { $(this).on("resize", $special.handler); },
		teardown: function () { $(this).off("resize", $special.handler); },
		handler: function (event, execAsap) {
			// Save the context
			var context = this,
					args = arguments,
					dispatch = function () {
						// set correct event type
						event.type = "debouncedresize";
						$event.dispatch.apply(context, args);
					};
			if (resizeTimeout) {
				clearTimeout(resizeTimeout);
			}
			execAsap ? dispatch() : resizeTimeout = setTimeout(dispatch, $special.threshold);
		},
		threshold: 150
	};
})(jQuery);

function resetActiveTile(withTransition) {
	// hide any placed meeples and their outlines
	$('#meeple-placements').attr('visibility', 'hidden');
	$('#meeple-placements image').attr('visibility', 'hidden');
	// hide the tower placements
	$('.tower-outline,.placed-tower').attr('visibility', 'hidden');
	// change back to default meeple placement mode
	changeMeepleMode();
	// show the meeples in the score area as they are no longer placed
	$('#score-area image').removeAttr('visibility');
	// remove data stored regarding the active tile position
	$('#active-tile').removeData('rotationIndex').removeData('placementIndex');
	// remove any selected move
	selectedMove = null;

	if(withTransition) {
		var startingScale = reverseScale;
		var startingTranslationX = reverseTranslation[0];
		var startingTranslationY = reverseTranslation[1];
		d3.selectAll('#confirm-button,#send-move-button').transition().duration(transitionDuration).attr('opacity', 0);
		d3.selectAll('#confirm-button,#send-move-button').transition().delay(transitionDuration).attr('visibility', 'hidden');
		d3.selectAll('#confirm-button > *').transition().delay(transitionDuration).attr('visibility', null);
		d3.select('#active-tile').transition().duration(transitionDuration).attr({
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		}).each('end', function() {
			// check to see if zoom or pan has happened since this transition began and redraw if so
			if(reverseScale !== startingScale ||
			   reverseTranslation[0] !== startingTranslationX ||
			   reverseTranslation[1] !== startingTranslationY) {
				resetActiveTile(true);
			}
		});
		d3.select('#active-tile-rotation-indicator').transition().duration(transitionDuration).attr({
			opacity: 0,
			visibility: null
		});
	} else {
		d3.selectAll('#confirm-button,#send-move-button').transition().duration(0).attr({
			opacity: 0,
			visibility: 'hidden'
		});
		d3.selectAll('#confirm-button > *').attr('visibility', null);
		d3.select('#active-tile').attr({
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		});
		d3.select('#active-tile-rotation-indicator').attr({
			opacity: 0,
			visibility: null
		});
	}
}

function changeMeepleMode(newMode) {
	if(newMode === undefined) {
		// activate the meeple placement mode for the first (minimum x value) existing meeple if there is one
		var firstFoundMeepleClass = $('.score-group:first image[class$="-meeple"]').sort(function(a, b) {
			return parseFloat(a.attributes.x.value) > parseFloat(b.attributes.x.value);
		}).first().attr('class');
		if(!firstFoundMeepleClass) {
			return;
		}
		newMode = firstFoundMeepleClass.slice(0,-7);
	}

	// update all meeple placements (outlines and actual meeples) with the appropriate size and image
	var size = newMode !== 'normal'  ? tileSize * 3 / 8 : tileSize / 4;
	d3.selectAll('#meeple-placements image').attr({
		width: size,
		height: size,
		x: -size / 2,
		y: -size / 2,
		'xlink:href': function(d) {
			var suffix = newMode === 'normal' || newMode === 'large' ? (d.locationType === 'farm' ? 'lying' : 'standing') : newMode;
			return this.attributes.href.value.replace(/_[^\.]*/, '_' + suffix);
		}
	});

	// do nothing else if the mode doesn't actually change
	if(newMode === meeplePlacementMode) {
		return;
	}

	// show clickable cursor on deactivating mode, show default cursor on activating mode
	var firstScoreGroup = d3.select('.score-group');
	firstScoreGroup.selectAll('.' + meeplePlacementMode + '-meeple').attr({ cursor: 'pointer' });
	firstScoreGroup.selectAll('.' + newMode + '-meeple').attr({ cursor: null });

	if(selectedMove && selectedMove.meeple) {
		// unhide (pick up) all meeples to start with
		firstScoreGroup.selectAll('image').attr('visibility', null);
		// the only way for the placement to still be valid is if we are changing between large and normal placements
		if((newMode === 'normal' && meeplePlacementMode === 'large') ||
		   (newMode === 'large' && meeplePlacementMode === 'normal')) {
			selectedMove.meeple.meepleType = newMode;
			// hide the newly placed meeple (reselect is necessary to still get just the first element and avoid rebinding data: https://github.com/mbostock/d3/wiki/Selections#select)
			d3.select(firstScoreGroup.selectAll('.' + newMode + '-meeple')[0][0]).attr('visibility', 'hidden');
		} else {
			// this placement is no longer valid
			// remove the move and hide any placed meeples
			delete selectedMove.meeple;
			d3.selectAll('#meeple-placements .placed-meeple').attr('visibility', 'hidden');
		}
	}
	meeplePlacementMode = newMode;
	updateMeeplePlacements(false);
}

function updateMeeplePlacements(withTransition) {
	// if the active tile isn't laid down on a valid placement don't update the meeple placement information as it will be done when the tile is placed
	if(!selectedMove) {
		return;
	}
	// show outlines for any valid meeple placements and rotate them appropriately
	var validMeeplePlacements = selectedMove.placement.rotations[selectedMove.rotationIndex].meeples;
	var container = d3.select('#meeple-placements');
	container.selectAll('image.meeple-outline').transition().duration(withTransition ? transitionDuration : 0).attr({
		visibility: function(d) {
			for(var i = 0; i < validMeeplePlacements.length; i++) {
				if(validMeeplePlacements[i].meepleType === (meeplePlacementMode === 'large' ? 'normal' : meeplePlacementMode) &&
				   validMeeplePlacements[i].locationType === d.locationType &&
				   validMeeplePlacements[i].index === d.index) {
					// remove hidden visibility attribute
					return null;
				}
			}
			return 'hidden';
		},
		transform: function() {
			return 'rotate(' + -selectedMove.rotation * 90 + ')';
		}
	});
	// remove meeple placement from the move and hide placed meeple if old placement is no longer valid
	container.selectAll('image.placed-meeple').transition().duration(withTransition ? transitionDuration : 0).attr({
		visibility: function(d) {
			// keep null visibility attribute if we find this placement in the valid placements
			for(var i = 0; i < validMeeplePlacements.length; i++) {
				if(validMeeplePlacements[i].meepleType === (meeplePlacementMode === 'large' ? 'normal' : meeplePlacementMode) &&
				   validMeeplePlacements[i].locationType === d.locationType &&
				   validMeeplePlacements[i].index === d.index) {
					// remove hidden visibility attribute
					return $(this).attr('visibility');
				}
			}
			// otherwise show any hidden meeples in the score area delete the selected move
			if(selectedMove &&
			   selectedMove.meeple &&
			   selectedMove.meeple.locationType === d.locationType &&
			   selectedMove.meeple.index === d.index) {
				$('#score-area image').removeAttr('visibility');
				delete selectedMove.meeple;
			}
			// and hide this placed meeple
			return 'hidden';
		},
		transform: function() {
			return 'rotate(' + -selectedMove.rotation * 90 + ')';
		}
	});
	// rotate the tower outline on the active tile
	d3.selectAll('#active-tile image.tower-outline,#active-tile image.placed-tower').transition().duration(withTransition ? transitionDuration : 0).attr({
		transform: function(d) {
			return 'translate(' + (d.offset.x - 1/2) * tileSize + ',' + (d.offset.y - 1/2) * tileSize + ') rotate(' + -selectedMove.rotation * 90 + ')';
		}
	});
}

$(document).ready(function() {
	// maybe avoid getting some spam with this
	$('#author-name').replaceWith('<a href="mailto:' + 'btouellette+concarneau' + '@' + 'gmail.com' + '">Brian Ouellette</a>');

	$('#btc-donate').qtip({
		prerender: true,
		content: {
			text: '<img src="/content/images/ui/bitcoin_qr.png" class="btc-qr"></img>13C6vXxhQuSrGs628imU8ug2xvachM6pJ2'
		},
		style: {
			classes: 'qtip-bootstrap'
		},
		position: {
			my: 'bottom center',
			at: 'top center',
			viewport: $(window),
			adjust: {
				method: 'shift'
			}
		},
		show: {
			event: 'mouseenter click',
			delay: 200
		},
		hide: {
			event: 'unfocus mouseleave',
			delay: 500
		},
		events: {
			render: function(event, api) {
				$(this).attr('id', 'btc-popup');
				// detect when it was clicked and store it
				api.elements.target.click(function(e) {
					api.wasClicked = !api.wasClicked;
				});
			},
			hide: function(event, api) {
				// if we're hiding and it was previously clicked stop, if it gets hidden unset the clicked status
				if((api.wasClicked && (event.originalEvent.type === 'mouseleave' || event.originalEvent.type === 'mouseout')) ||
				   $('#btc-popup').is(":hover")) {
					try{ event.preventDefault(); } catch(e) {}
				} else {
					api.wasClicked = false;
				}
			}
		}
	});

	$('#game-menu .fa-plus-square-o').qtip({
		content: {
			text: '<div id="new-game-popup">' +
					'<div>Click friends to add to game:</div>' +
					'<div id="solo-notifier"><svg class="fa-exclamation-triangle"><use xlink:href="#fa-exclamation-triangle"></use></svg> Currently playing solo</div>' +
				  '</div>' +
				  '<button type="button" id="new-game-cancel" class="btn btn-default btn-sm">Cancel</button>' +
				  '<button id="new-game-send" type="button" class="btn btn-default btn-sm">Start</button>' +
				  <% if (/*['gatskee','crmack','novamute','mom','werxes','greatgatskee','blakestock','evan'].indexOf(user.username) !== -1*/ true) { %>
				  '<div id="expansion-header">Expansions:</div>' +
				  '<div><label class="expansion-label">' +
					'<input type="checkbox" id="inns-and-cathedrals-checkbox" class="expansion-checkbox"> <a target="_blank" href="http://zmangames.com/rulebooks/Carcassonne_Exp1.pdf">Inns and Cathedrals</a>' +
				  '</label></div>' +
				  '<div><label class="expansion-label">' +
					'<input type="checkbox" id="traders-and-builders-checkbox" class="expansion-checkbox"> <a target="_blank" href="http://zmangames.com/rulebooks/Carcassonne_Exp2.pdf">Traders and Builders</a>' +
				  '</label></div>' +
				  //'<div><label class="expansion-label">' +
				  //  '<input type="checkbox" id="the-tower-checkbox" class="expansion-checkbox"> <a target="_blank" href="http://zmangames.com/rulebooks/Carcassonne_Exp4.pdf">The Tower</a>' +
				  //'</label></div>' +
				  <% } %>
				  ''
		},
		style: {
			classes: 'qtip-bootstrap',
			tip: {
				corner: false
			}
		},
		position: {
			my: 'left center',
			at: 'center right',
			viewport: $(window),
			adjust: {
				method: 'shift',
				x: 249
			}
		},
		show: {
			event: 'click'
		},
		hide: {
			event: 'click'
		},
		events: {
			show: function() {
				$('#new-game-popup .friend-listing').remove();
				$('#friends-menu .fa-edit').hide();
				$('#friends-menu-selection').click();
				// hide user symbols
				$('#friends-list .fa-user').attr('class','fa-user hidden');
				// unhide add symbols
				$('#friends-list .fa-plus-square-o').attr('class','fa-plus-square-o');
				$('#friends-list .friend-listing').on('click', function() {
					if($('#new-game-popup .friend-listing').length < 5) {
						$('#solo-notifier').hide();
						var element = $(this);
						element.clone().attr('id', 'add-' + element.attr('id')).css('cursor', 'default').addClass('add-friend-listing').appendTo('#new-game-popup');
						$('#add-' + element.attr('id') + ' svg').remove();
					}
				});
			},
			hide: function() {
				$('#friends-menu .fa-edit').show();
				$('#game-menu-selection').click();
				$('#friends-list .fa-plus-square-o').attr('class','fa-plus-square-o hidden');
				$('#friends-list .fa-user').attr('class','fa-user');
				$('#friends-list .friend-listing').off('click');
				$('#solo-notifier').delay(250).show(0);
			},
			render: function(e, api) {
				$('#new-game-cancel', this).click(function(event) {
					api.hide(event);
					event.preventDefault();
				});
				$('#new-game-send', this).click(function(event) {
					var friends = [];
					$('.add-friend-listing').each(function() {
						friends.push(this.id.substr(11));
					});
					var expansions = ['base-game'];
					$('.expansion-checkbox:checked').each(function() {
						expansions.push(this.id.slice(0,-9));
					});
					socket.emit('new game', friends, expansions);
					api.hide(event);
					event.preventDefault();
				});
			}
		}
	});

	$('#add-friend-form').on('submit', function(e) {
		e.preventDefault();
		socket.emit('add friend', $('#add-friend-input').val());
	});

	$('#chat-message-form').on('submit', function(e) {
		e.preventDefault();
		var input = $('#chat-message-input');
		socket.emit('sending message', input.val(), currentGameID);
		input.val('');
	});

	// Listen for Enter keypresses and trigger move submission
	jQuery.fn.d3Click = function () {
		this.each(function (i, e) {
			var evt = new MouseEvent("click");
			e.dispatchEvent(evt);
		});
	};
	$(document).keypress(function (event) {
		// Ignore enter keypress if it is to send a chat message
		if(event.target.id !== 'chat-message-input'  && (event.which == 13 || event.keyCode == 13)) {
			var sendVisible = $('#send-move-button').css('visibility') !== 'hidden';
			var confirmVisible = $('#confirm-button').css('visibility') !== 'hidden';
			if(sendVisible) {
				$('#send-move-button').d3Click();
			} else if(confirmVisible) {
				$('#confirm-button').d3Click();
			}
		}
	});

	// Play a silent sound so that we can play background audio later if needed
	if($('#sound-notifications-checkbox').is(':checked')) {
		var bell = new Audio('/content/sounds/church-bell.mp3');
		bell.volume = 0;
		bell.play();
	}

	// Load in SVG icons
	var c = new XMLHttpRequest();
	c.open('GET', '/content/images/ui/icons.svg', false);
	c.setRequestHeader('Content-Type', 'text/xml');
	c.send();
	document.body.insertBefore(c.responseXML.firstChild, document.body.firstChild);

	var lastGamestate;

	var zoom = d3.behavior.zoom().scaleExtent([0.25, 1]).on('zoom', function() {
		//d3.event.sourceEvent.preventDefault();
		reverseScale = 1/d3.event.scale;
		reverseTranslation = d3.event.translate.map(function(item) { return -1 * item; });
		gameArea.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
		if(!selectedMove) {
			resetActiveTile(false);
		}
	});

	var svg = d3.select('#game-svg').call(zoom).on("dblclick.zoom", null);

	var gameArea = svg.append('g').attr({ id: 'game-area' });
	var placedTileImages = gameArea.append('g').attr({ id: 'placed-tile-images' });
	var placedTilePieces = gameArea.append('g').attr({ id: 'placed-tile-pieces' });
	var turnMarkerArea = gameArea.append('g').attr({ id: 'turn-markers' });
	var placements = gameArea.append('g').attr({ id: 'valid-placements' });
	var activeTileContainer = gameArea.append('g').attr({ id: 'active-tile' });
	var activeTileImageContainer = activeTileContainer.append('g').attr({ id: 'active-tile-translation', transform: 'translate(' + tileSize / 2 + ',' + tileSize / 2 + ')' })
													  .append('g').attr({ id: 'active-tile-rotation' });
	activeTileImageContainer.append('use').attr({
		id: 'active-tile-rotation-indicator',
		'xlink:href': '#svgicon-repeat-payment',
		x: -16,
		y: -16,
		transform: 'scale(' + tileSize / 32 + ')',
		fill: 'white',
		stroke: 'black',
		opacity: 0,
		'pointer-events': 'none'
	});
	var meeplePlacements = activeTileImageContainer.append('g').attr({
		id: 'meeple-placements',
		visibility: 'hidden'
	});

	var uiArea = svg.append('g').attr({ id: 'ui-area' });
	var scoreArea = uiArea.append('g').attr({ id: 'score-area' });
	scoreArea.append('rect').attr({
		id: 'score-bg',
		rx: 15,
		ry: 15,
		x: -15,
		y: -15,
		fill: 'white',
		stroke: 'black',
		'stroke-width': 2,
		opacity: 0.75
	});
	var sendMoveButton = uiArea.append('g').attr({
		id: 'send-move-button',
		cursor: 'pointer',
		visibility: 'hidden'
	}).on('click', function() {
		if(selectedMove) {
			socket.emit('sending move', currentGameID, selectedMove, $('#test-complete').is(':checked'));
			// while waiting for the next gamestate hide any tile placements and the send move button
			d3.selectAll('#send-move-button,.tile-placements').transition().duration(transitionDuration+1500).attr('opacity', 0);
		}
	});
	sendMoveButton.append('circle').attr({
		cy: 5 + tileSize / 2,
		cx: $('#svg-wrapper').width() - 5 - tileSize / 2,
		r: 30,
		fill: 'green',
		stroke: 'black',
		'stroke-width': 5
	});
	sendMoveButton.append('use').attr({
		'xlink:href': '#svgicon-transfer',
		x: $('#svg-wrapper').width() - 5 - tileSize / 2 - 16,
		y: 5 + tileSize / 2 - 16
	});
	var confirmButton = uiArea.append('g').attr({
		id: 'confirm-button',
		cursor: 'pointer',
		visibility: 'hidden'
	}).on('click', function() {
		d3.selectAll('#confirm-button,#active-tile-rotation-indicator').attr('visibility', 'hidden');
		d3.select('#send-move-button').attr({
			visibility: null,
			opacity: 1
		});
		d3.select('#meeple-placements').attr('visibility', null);
		d3.selectAll('.tower-outline').attr('visibility', null);
	});
	confirmButton.append('circle').attr({
		cy: 5 + tileSize / 2,
		cx: $('#svg-wrapper').width() - 5 - tileSize / 2,
		r: 30,
		fill: 'green',
		stroke: 'black',
		'stroke-width': 5
	});
	confirmButton.append('use').attr({
		'xlink:href': '#svgicon-selecting-from-list',
		x: $('#svg-wrapper').width() - 5 - tileSize / 2 - 16,
		y: 5 + tileSize / 2 - 16
	});

	function timeSince(date) {
	  var seconds = Math.floor((new Date() - date) / 1000);
	  var interval = Math.floor(seconds / 31536000);
	  if (interval >= 1) {
	    return interval + "y";
	  }
	  interval = Math.floor(seconds / 86400);
	  if (interval >= 1) {
	    return interval + "d";
	  }
	  interval = Math.floor(seconds / 3600);
	  if (interval >= 1) {
	    return interval + "h";
	  }
	  interval = Math.floor(seconds / 60);
	  if (interval >= 1) {
	    return interval + "m";
	  }
	  return Math.floor(seconds) + "s";
	}

	function addNewGameListing(game, menuGroup) {
		var gameID = game._id;
		var element = '<div class="menu-game-listing" id="game-' + gameID + '">';
		// add remaining tiles text
		element += '<span class="right-side">'
		element += '<div><span class="tile-count">[' + (game.unusedTiles.length + (game.finished ? 0 : 1)) + ']</span></div>';
		if (game.players.length > 1) {
			element += '<div><span class="time-since">' + timeSince(new Date(game.lastModified)) + '</span></div>';
		}
		element += '<svg class="fa-trash-o hidden"><use xlink:href="#fa-trash-o"></use></svg>'
		element += '</span>';
		// add sub divs for each user in the game
		element += game.players.map(function(item) {
			return '<div class="game-player-listing">' + (item.active ? '&lt;' + item.user.username+ '&gt;' : item.user.username) + '</div>';
		}).join('');
		element += '</div>';
		// when the game listing is clicked load that game
		$(element).click(function() {
			socket.emit('load game', gameID);
			$('#chat-wrapper').removeClass('hidden');
			$('#menu-checkbox').attr('checked', false);
			currentGameID = gameID;
		}).appendTo(menuGroup);
		// show the game delete/edit button in case it was hidden
		$('#game-menu .fa-edit').attr('class','fa-edit');
	}

	// draw the menus
	var $gameListings = $('#game-menu');
	var $activeGames = $('#active-games');
	var $inactiveGames = $('#inactive-games');
	var $finishedGames = $('#finished-games');
	// add the active games and separate waiting and finished games
	for(var i = 0; i < userGames.length; i++) {
		if(userGames[i].finished) {
			if($gameListings.has('#game-' + userGames[i]._id).length) {
				$('#game-' + userGames[i]._id).appendTo($finishedGames);
			} else {
				addNewGameListing(userGames[i], $finishedGames);
			}
		} else {
			var active = false;
			for(var k = 0; k < userGames[i].players.length; k++) {
				if(userGames[i].players[k].user._id === userID &&
				   userGames[i].players[k].active) {
					active = true;
					if($gameListings.has('#game-' + userGames[i]._id).length) {
						$('#game-' + userGames[i]._id).appendTo($activeGames);
					} else {
						addNewGameListing(userGames[i], $activeGames);
					}
					break;
				}
			}
			if(!active) {
				if($gameListings.has('#game-' + userGames[i]._id).length) {
					$('#game-' + userGames[i]._id).appendTo($inactiveGames);
				} else {
						addNewGameListing(userGames[i], $inactiveGames);
				}
			}
		}
	}
	// set up the friends menu
	var friends = userFriends.sort(function(a, b) {
		var username_a = a.username.toLowerCase();
		var username_b = b.username.toLowerCase();
		if(username_a  > username_b) {
			return 1;
		}
		if(username_a < username_b) {
			return -1;
		}
		return 0;
	});
	var $friendsList = $('#friends-menu');
	// show the friends edit button if there are friends to potentially delete
	if(friends.length > 0) {
		$friendsList.find('.fa-edit').attr('class','fa-edit');
	}
	for(var j = 0; j < friends.length; j++) {
		if($friendsList.has('#friend-' + friends[j]._id).length === 0) {
			// insert the new friend in alphabetical order by display name
			var element = '<div class="friend-listing" id="friend-' + friends[j]._id + '"><svg class="fa-trash-o hidden"><use xlink:href="#fa-trash-o"></use></svg><svg class="fa-plus-square-o hidden"><use xlink:href="#fa-plus-square-o"></use></svg><svg class="fa-user"><use xlink:href="#fa-user"></use></svg> ' + friends[j].username + '</div>';
			if(j === 0) {
				$(element).appendTo("#friends-list");
			} else {
				$(element).insertAfter('#friend-' + friends[j-1]._id);
			}
		}
	}

	// reset the active tile if the user clicks the background and isn't doing a zoom/pan
	d3.select('#game-background').on('click', function() {
		if (d3.event.defaultPrevented === false) {
			resetActiveTile(true);
		}
	});
	// update the SVG on resize
	$(window).on("debouncedresize", function () { if(lastGamestate) { draw(lastGamestate); }});
	// listen for new gamestate data from the server
	socket.on('sending gamestate', function(gamestate, loadingGame) {
		// update the tile count in the menu
		$('#game-' + gamestate._id + ' .tile-count').text('[' + (gamestate.unusedTiles.length + (gamestate.finished ? 0 : 1)) + ']');
		// put the game listing in the correct place in the menu
		var $activeGames = $('#active-games');
		var $inactiveGames = $('#inactive-games');
		var $finishedGames = $('#finished-games');
		var $newGame = $('#game-' + gamestate._id);
		// mark the active players name with <username> in the game list
		var activePlayerIndex = 0;
		while(!gamestate.players[activePlayerIndex].active && activePlayerIndex < gamestate.players.length) {
			activePlayerIndex++;
		}
		$newGame.children('.game-player-listing').text(function(i, text) {
			var username = text.replace('<','').replace('>','');
			return (i === activePlayerIndex ? '<' + username + '>' : username)
		});
		// put the game listing in the correct category in the menu
		if(gamestate.finished) {
			if($finishedGames.has($newGame).length === 0) {
				$newGame.appendTo($finishedGames);
			}
		} else {
			var active = false;
			for(var k = 0; k < gamestate.players.length; k++) {
				if(gamestate.players[k].user._id === userID &&
				   gamestate.players[k].active) {
					active = true;
					if($activeGames.has($newGame).length === 0) {
						$newGame.appendTo($activeGames);
					}
					break;
				}
			}
			if(!active) {
				if($inactiveGames.has($newGame).length === 0) {
					$newGame.appendTo($inactiveGames);
				}
			}
		}
		// update the page title to inform the user there is something new if it is their turn
		if(gamestate.players[activePlayerIndex].user._id === userID && !loadingGame) {
			document.title = '(!) Concarneau';
			$('body').on('mousemove', function() {
				document.title = 'Concarneau';
				$('body').off('mousemove');
			});
			// if the sound notifications are enabled play one
			if($('#sound-notifications-checkbox').is(':checked')) {
				new Audio('/content/sounds/church-bell.mp3').play();
			}
		}
		// if this is the first time loading this game clear the chat list and redraw all messages
		if(loadingGame) {
			// draw chat messages into chat box grouped by username
			$('#chat-header-label span').text(' Chat');
			var $chatBody = $('#chat-body');
			var $messageList = $('#chat-message-list').detach();
			$messageList.empty();
			var index = 0;
			while(index < gamestate.messages.length) {
				var username = gamestate.messages[index].username;
				var messageGroup = [];
				while(messageGroup.length === 0 ||
					  (index < gamestate.messages.length && gamestate.messages[index].username === username)) {
					messageGroup.push(gamestate.messages[index].message);
					index++
				}
				// if there is no username this is a system generated message so don't draw a username and apply the system message class
				var $li = username === null ? $('<li>') : $('<li>').append($('<div class="chat-user-name">').text(username + ':'));
				for(var j = 0; j < messageGroup.length; j++) {
					$li.append($(username === null ? '<div class="chat-system-message">' : '<div class="chat-message">').text(messageGroup[j]));
				}
				$messageList.append($li);
			}
			$chatBody.append($messageList);
			// scroll chat messages to bottom
			$chatBody.scrollTop($chatBody[0].scrollHeight);
			$('#chat-footer input').val('');
			$('#chat-wrapper').removeClass('hidden');
		} else if (currentGameID === gamestate._id &&
				   gamestate.messages &&
				   gamestate.messages.length > 0 &&
				   gamestate.messages[gamestate.messages.length - 1].username === null) {
			// if not the first time loading this game (and this is the actively displayed game) draw any new messages from the server
			var lastServerMessage = $('#chat-message-list .chat-system-message').last().text();
			var i = gamestate.messages.length - 1;
			var newMessages = [];
			while(i >= 0 && gamestate.messages[i].username === null && gamestate.messages[i].message !== lastServerMessage) {
				newMessages.unshift(gamestate.messages[i].message);
				i--;
			}
			for(var k = 0; k < newMessages.length; k++) {
				addMessageToChat(newMessages[k], null);
			}
		}
		// only draw if we are loading or are currently viewing this game
		if(currentGameID === gamestate._id) {
			draw(gamestate);
		}
	});
	socket.on('game started', function(gamestate, startingUserID) {
		// add to active or inactive games depending on which this player is
		var $activeGames = $('#active-games');
		var $inactiveGames = $('#inactive-games');
		var active = false;
		for(var k = 0; k < gamestate.players.length; k++) {
			if(gamestate.players[k].user._id === userID &&
			   gamestate.players[k].active) {
				active = true;
				addNewGameListing(gamestate, $activeGames);
				break;
			}
		}
		if(!active) {
			addNewGameListing(gamestate, $inactiveGames);
		}
		// get the index of the active player
		var activePlayerIndex = 0;
		while(!gamestate.players[activePlayerIndex].active && activePlayerIndex < gamestate.players.length) {
			activePlayerIndex++;
		}
		// draw if this user triggered the new game
		// if it is the players turn update the page title to inform the user there is a game to play a move in
		if(userID === startingUserID) {
			$('#chat-header-label span').text(' Chat');
			$('#chat-message-list').empty();
			$('#chat-wrapper').removeClass('hidden');
			currentGameID = gamestate._id;
			draw(gamestate);
		} else if(gamestate.players[activePlayerIndex].user._id === userID) {
			document.title = '(!) Concarneau';
			$('body').on('mousemove', function() {
				document.title = 'Concarneau';
				$('body').off('mousemove');
			});
			// if the sound notifications are enabled play one
			if($('#sound-notifications-checkbox').is(':checked')) {
				new Audio('/content/sounds/church-bell.mp3').play();
			}
		}
	});
	socket.on('friend added', function(username, userID) {
		// found a user with this username, add to the friends list in the menu and flash a success message
		var $alert = $('#username-alert');
		$alert.text('Added!');
		$alert.removeClass('alert-danger').addClass('alert-success').fadeTo(0, 1).fadeTo(3500, 0);
		// insert into the friends list alphabetically
		var element = '<div class="friend-listing" id="friend-' + userID + '"><svg class="fa-trash-o hidden"><use xlink:href="#fa-trash-o"></use></svg><svg class="fa-user"><use xlink:href="#fa-user"></use></svg> ' + username + '</div>';
		var $listings = $('.friend-listing');
		if($listings.length === 0) {
			$(element).appendTo('#friends-list');
		} else {
			$listings.each(function(index) {
				if($listings.length <= index + 1 ||
				   $($listings[index+1]).text().trim() > username) {
					$(element).insertAfter(this);
					return false;
				}
			});
		}
		// make sure the edit button is shown
		$('#friends-menu .fa-edit').attr('class','fa-edit');
	});
	socket.on('friend not found', function() {
		// couldn't find a user with this username, flash an error message
		var $alert = $('#username-alert');
		$alert.text('Username not found!');
		$alert.removeClass('alert-success').addClass('alert-danger').fadeTo(0, 1).fadeTo(3500, 0);
	});
	socket.on('message sent', function(message, username, gameID) {
		// add any received messages for the current game to the chatbox
		if(gameID === currentGameID) {
			addMessageToChat(message, username);
		}
	});

	function addMessageToChat(message, username) {
		var $chatBody = $('#chat-body');
		var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
		// add the message either to the username group if it hasn't changed (and the last message was a chat not a system message) or create a new one
		if(username !== null &&
		   $chatBody.find('.chat-user-name').last().text() === username + ':' &&
		   $chatBody.find('div').last().hasClass('chat-message')) {
			$('#chat-message-list li').last().append($('<div class="chat-message">').text(message));
		} else if(username !== null) {
			$('#chat-message-list').append(
				$('<li>').append(
					$('<div class="chat-user-name">').text(username + ':')
				).append(
					$('<div class="chat-message">').text(message)
				)
			);
		} else {
			$('#chat-message-list').append(
				$('<li>').append(
					$('<div class="chat-system-message">').text(message)
				)
			);
		}
		// scroll the chat list down if the user was already at the bottom of it
		// otherwise inform of the new message until they scroll down
		if(scrolledToBottom && !$chatBody.is(':hidden')) {
			$chatBody.scrollTop($chatBody[0].scrollHeight);
		} else {
			$('#chat-header-label span').text(' Chat (!)');
			$('#chat-toggle a').on('click.update-header', function() {
				$('#chat-header-label span').text(' Chat');
				$(this).off('click.update-header');
			})
			$chatBody.bind('scroll', function(e) {
				var $chatBody = $(e.currentTarget);
				var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
				if(scrolledToBottom) {
					$('#chat-header-label span').text(' Chat');
					$chatBody.off('scroll');
				}
			});
		}
	}

	function draw(gamestate) {
		svgHeight = $('#svg-wrapper').height();
		svgWidth = $('#svg-wrapper').width();
		// if this SVG isn't visible don't update it
		if (svgWidth === 0 || svgHeight === 0) {
			return;
		}

		lastGamestate = gamestate;

		// position the buttons under the active tile image in the upper right
		d3.selectAll('#confirm-button > circle,#send-move-button > circle').attr({
			cx: svgWidth - 5 - tileSize / 2
		});
		d3.selectAll('#confirm-button > use,#send-move-button > use').attr({
			x: svgWidth - 5 - tileSize / 2 - 16
		});

		resetActiveTile(false);

		// rotate the player array such that this player is on top
		// go through the entire array to ensure that if this player is in the game multiple times the active version is on top
		var playerCount = gamestate.players.length;
		var count = 0;
		var reorderedPlayers = gamestate.players.slice(0);
		while(reorderedPlayers[0].user._id !== userID ||
			  (!reorderedPlayers[0].active && count < playerCount)) {
			count++;
			reorderedPlayers.push(reorderedPlayers.shift());
		}
		// get the number of remaining meeples and the color
		var meepleColor = reorderedPlayers[0].color;
		var remainingMeeples = reorderedPlayers[0].remainingMeeples;
		var userIsActive = reorderedPlayers[0].active;

		// for all newly placed tiles add a group for the placed tile and its meeples
		var placedTileImage = placedTileImages.selectAll('image.placed-tile-image').data(gamestate.placedTiles);
		placedTileImage.enter().append('image').attr({
			class: 'placed-tile-image',
			x: 0,
			y: 0,
			width: tileSize,
			height: tileSize
		});
		placedTileImage.attr({
			transform: function(d) {
				var x = svgWidth / 2 + d.x * tileSize;
				var y = svgHeight / 2 + d.y * tileSize;
				return 'rotate(' + 90 * d.rotation + ',' + (x + tileSize / 2) + ',' + (y + tileSize / 2) + ') translate(' + x + ',' + y + ')';
			},
			'xlink:href': function(d) { return d.tile.imageURL; }
		});
		placedTileImage.exit().remove();

		var tileGroup = placedTilePieces.selectAll('g.placed-tile').data(gamestate.placedTiles);
		tileGroup.enter().append('g').attr({
			class: 'placed-tile'
		}).append('g').attr({
			class: 'tower-pieces'
		});
		tileGroup.attr({
			transform: function(d) {
				var x = svgWidth / 2 + d.x * tileSize;
				var y = svgHeight / 2 + d.y * tileSize;
				return 'rotate(' + 90 * d.rotation + ',' + (x + tileSize / 2) + ',' + (y + tileSize / 2) + ') translate(' + x + ',' + y + ')';
			}
		});
		tileGroup.exit().remove();

		// then draw the meeples placed on the tiles
		var meepleImages = tileGroup.selectAll('image.meeple').data(function(d) {
			return d.meeples.map(function(item) {
				return {
					color: gamestate.players[item.playerIndex].color,
					rotation: d.rotation,
					location: item.placement.locationType,
					meepleType: item.meepleType,
					meepleOffset:
						item.placement.locationType === 'cloister' ?
							{ x: 1/2, y: 1/2 } :
						item.placement.locationType === 'city' ?
							d.tile['cities'][item.placement.index].meepleOffset :
							d.tile[item.placement.locationType + 's'][item.placement.index].meepleOffset
				};
			});
		});
		// adding any new meeples
		meepleImages.enter().append('image').attr({
			class: 'meeple',
			width: function(d) { return d.meepleType !== 'normal' ? tileSize * 3 / 8 : tileSize / 4 },
			height: function(d) { return d.meepleType !== 'normal'  ? tileSize * 3 / 8 : tileSize / 4; }
		});
		meepleImages.attr({
			x: function(d) { return tileSize * d.meepleOffset.x - (d.meepleType !== 'normal'  ? tileSize * 3 / 8 : tileSize / 4) / 2; },
			y: function(d) { return tileSize * d.meepleOffset.y - (d.meepleType !== 'normal'  ? tileSize * 3 / 8 : tileSize / 4) / 2; },
			'xlink:href': function(d) {
				return '/content/images/meeples/' + d.color + '_' + (d.meepleType !== 'normal' && d.meepleType !== 'large' ? d.meepleType : (d.location === 'farm' ? 'lying' : 'standing')) +'.png';
			},
			transform: function(d) {
				return 'rotate(' + d.rotation * -90 + ',' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')';
			}
		});
		// and removing any meeples that have been picked up
		meepleImages.exit().remove();

		var towerVerticalSize = tileSize / 12;
		var placedTileTowers = tileGroup.select('g.tower-pieces').selectAll('image.tower').data(function(d, i) {
			if(!d.tower) {
				return [];
			}
			var towerData = [];
			for(var i = 0; i < d.tower.height; i++) {
				towerData.push({
					offset: d.tile.tower.offset,
					tileRotation: d.rotation,
					towerHeight: i
				});
			}
			return towerData;
		});
		placedTileTowers.enter().append('image').attr({
			class: 'tower',
			width: tileSize / 3,
			height: tileSize / 3,
			'xlink:href': '/content/images/meeples/tower.png'
		});
		placedTileTowers.attr({
			x: function(d) { return d.offset.x * tileSize - tileSize / 6; },
			y: function(d) { return d.offset.y * tileSize - tileSize / 6 - towerVerticalSize * d.towerHeight; },
			transform: function(d) {
				return 'rotate(' + d.tileRotation * -90 + ',' + d.offset.x * tileSize + ',' + d.offset.y * tileSize + ')';
			}
		});
		placedTileTowers.exit().remove();

		function towerOutlineClicked(d, i) {
			// hide any placed meeples
			$('.placed-tower,.placed-meeple').attr('visibility', 'hidden');
			// show all meeples from the score area
			$('.score-group image').removeAttr('visibility');
			// show the placed tower
			$(this).siblings('.placed-tower').removeAttr('visibility');
			delete selectedMove.meeple;
			selectedMove.tower = {
				tileIndex: d.tileIndex
			};
		}

		// then draw outlines for tower placement
		var placedTileTowerOutlines = tileGroup.selectAll('image.tower-outline').data(function(d, i) {
			if(!d.tile.tower || d.tower.completed) {
				return [];
			}
			return [{
				offset: d.tile.tower.offset,
				tileRotation: d.rotation,
				tileIndex: i,
				towerHeight: d.tower.height
			}];
		});
		// add any new outlines
		placedTileTowerOutlines.enter().append('image').attr({
			class: 'tower-outline',
			width: tileSize / 3,
			height: tileSize / 3,
			'xlink:href': '/content/images/meeples/outline_tower.png',
			visibility: 'hidden'
		}).on('click', towerOutlineClicked);
		placedTileTowerOutlines.attr({
			x: function(d) { return d.offset.x * tileSize - tileSize / 6; },
			y: function(d) { return d.offset.y * tileSize - tileSize / 6 - towerVerticalSize * d.towerHeight; },
			transform: function(d) {
				return 'rotate(' + d.tileRotation * -90 + ',' + d.offset.x * tileSize + ',' + d.offset.y * tileSize + ')';
			}
		});
		placedTileTowerOutlines.exit().remove();

		// then draw tower icons which will appear over the outline if selected
		var placedTileTowerPlacements = tileGroup.selectAll('image.placed-tower').data(function(d, i) {
			if(!d.tile.tower || d.tower.completed) {
				return [];
			}
			return [{
				offset: d.tile.tower.offset,
				tileRotation: d.rotation,
				tileIndex: i,
				towerHeight: d.tower.height
			}];
		})
		// add any new outlines
		placedTileTowerPlacements.enter().append('image').attr({
			class: 'placed-tower',
			width: tileSize / 3,
			height: tileSize / 3,
			'xlink:href': '/content/images/meeples/tower.png'
		});
		placedTileTowerPlacements.attr({
			x: function(d) { return d.offset.x * tileSize - tileSize / 6; },
			y: function(d) { return d.offset.y * tileSize - tileSize / 6 - towerVerticalSize * d.towerHeight; },
			transform: function(d) {
				return 'rotate(' + d.tileRotation * -90 + ',' + d.offset.x * tileSize + ',' + d.offset.y * tileSize + ')';
			},
			visibility: 'hidden'
		});
		placedTileTowerPlacements.exit().remove();

		// draw the active tile
		var activeTileImage = activeTileImageContainer.selectAll('#active-tile-image').data(gamestate.activeTile.tile ? [gamestate.activeTile.tile] : []);
		activeTileImage.enter().insert('image', '#active-tile-rotation-indicator').attr({
			width: tileSize,
			height: tileSize,
			id: 'active-tile-image',
			'pointer-events': 'none'
		});
		// reset to the base position and update the image URL every draw
		activeTileImage.attr({
			x: -tileSize / 2,
			y: -tileSize / 2,
			'xlink:href': function(d) { return d.imageURL; }
		});
		activeTileImage.exit().remove();
		//TODO: show discarded tiles being tossed

		// then draw an outline for tower placement on the active tile
		var activeTileTowerOutline = activeTileImageContainer.selectAll('image.tower-outline').data(function(d) {
			if(!gamestate.activeTile.tile || !gamestate.activeTile.tile.tower) {
				return [];
			}
			return [{
				offset: gamestate.activeTile.tile.tower.offset,
				tileIndex: $('.placed-tile').length
			}];
		})
		// add any new tower outlines needed
		activeTileTowerOutline.enter().append('image').attr({
			class: 'tower-outline',
			width: tileSize / 3,
			height: tileSize / 3,
			'xlink:href': '/content/images/meeples/outline_tower.png',
			visibility: 'hidden'
		}).on('click', towerOutlineClicked);
		// update the location of the tower outlines based on the offset value
		activeTileTowerOutline.attr({
			x: -tileSize / 6,
			y: -tileSize / 6,
			transform: function(d) {
				return 'translate(' + (d.offset.x - 1/2) * tileSize + ',' + (d.offset.y - 1/2) * tileSize + ')';
			}
		});
		activeTileTowerOutline.exit().remove();

		// then draw placed (on top of outline) towers on the active tile
		var activeTileTowerPlacement = activeTileImageContainer.selectAll('image.placed-tower').data(function(d) {
			if(!gamestate.activeTile.tile || !gamestate.activeTile.tile.tower) {
				return [];
			}
			return [{
				offset: gamestate.activeTile.tile.tower.offset
			}];
		})
		// add any new outlines
		activeTileTowerPlacement.enter().append('image').attr({
			class: 'placed-tower',
			width: tileSize / 3,
			height: tileSize / 3,
			'xlink:href': '/content/images/meeples/tower.png'
		});
		activeTileTowerPlacement.attr({
			x: -tileSize / 6,
			y: -tileSize / 6,
			transform: function(d) {
				return 'translate(' + (d.offset.x - 1/2) * tileSize + ',' + (d.offset.y - 1/2) * tileSize + ')';
			},
			visibility: 'hidden'
		});
		activeTileTowerPlacement.exit().remove();

		// draw the places where the active tile can be placed
		var validPlacements = placements.selectAll('image.tile-placements').data(userIsActive ? gamestate.activeTile.validPlacements : []);
		validPlacements.enter().append('image').attr({
			class: 'tile-placements',
			id: function(d, i) { return 'placement-' + i; },
			width: tileSize,
			height: tileSize,
			'xlink:href': '/content/images/ui/placement_available.png'
		});
		// transition all to visible overwriting the previous fade transition
		validPlacements.transition().attr({ opacity: 1 });
		validPlacements.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
			y: function(d) { return svgHeight / 2 + d.y * tileSize; }
		}).on('click', function (d, i) {
			var $activeTile = $('#active-tile');
			var rotationIndex;
			// if we have previously clicked this placement box move to the next valid rotation
			if($activeTile.data('placementIndex') === i) {
				rotationIndex = ($activeTile.data('rotationIndex') + 1) % d.rotations.length;
			} else {
				// if this is a new location reset to the first rotation
				rotationIndex = 0;
				// show all the remaining meeples in case one was temporarily placed and is returned to the pool
				$('#score-area image').removeAttr('visibility');
				// reset the move
				selectedMove = {
					placement: gamestate.activeTile.validPlacements[i]
				};
				// and reset the meeple mode if it was set
				changeMeepleMode();
				// show the placement confirmation again and hide the send move button, meeple outlines, and any placed meeples
				d3.selectAll('#meeple-placements,#send-move-button,#meeple-placements .placed-meeple').attr('visibility', 'hidden');
				d3.selectAll('#confirm-button').attr('visibility', null);
				d3.selectAll('#confirm-button').transition().duration(transitionDuration).attr('opacity', 1);
			}
			selectedMove.rotationIndex = rotationIndex;
			selectedMove.rotation = d.rotations[rotationIndex].rotation;
			var rotationDegrees = selectedMove.rotation * 90;
			// store data about this selection in the active tile
			$activeTile.data('rotationIndex', rotationIndex);
			$activeTile.data('placementIndex', i);
			// move the active tile over top of the placement box
			var x = parseInt($(this).attr('x'), 10);
			var y = parseInt($(this).attr('y'), 10);
			d3.select('#active-tile').transition().duration(transitionDuration).attr({
				transform: 'translate(' + x + ',' + y + ')'
			});
			d3.select('#active-tile-rotation').transition().duration(transitionDuration).attr({
				transform: 'rotate(' + rotationDegrees + ')'
			});
			// if there are rotations make the indicator visible
			d3.select('#active-tile-rotation-indicator').transition().duration(transitionDuration).attr({
				opacity: d.rotations.length > 1 ? 0.45 : 0,
				visibility: null
			});
			// check that there are normal meeples to place or that if in a special meeple placement mode that the "has(SpecialType)Meeple" flag is true for this player
			if((meeplePlacementMode === 'normal' && remainingMeeples > 0) ||
			   (meeplePlacementMode && reorderedPlayers[0]['has' + meeplePlacementMode.charAt(0).toUpperCase() + meeplePlacementMode.slice(1) + 'Meeple'])) {
				updateMeeplePlacements(true);
			}
		});
		validPlacements.exit().remove();

		// draw the potential meeple placement for the active tile
		// draw the outlines on which meeples can be placed
		var meepleOutlines = meeplePlacements.selectAll('g.outline-group').data(function() {
			var allMeepleLocations = [];
			if(gamestate.activeTile.tile) {
				allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.roads.map(function(item, index) { item.locationType = 'road'; item.index = index; return item; }));
				allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.farms.map(function(item, index) { item.locationType = 'farm'; item.index = index; return item; }));
				allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.cities.map(function(item, index) { item.locationType = 'city'; item.index = index; return item; }));
				if(gamestate.activeTile.tile.cloister) {
					allMeepleLocations = allMeepleLocations.concat([{ locationType: 'cloister', index: 0, meepleOffset: gamestate.activeTile.tile.cloister.meepleOffset }]);
				}
			}
			// if there were none of a certain type remove all undefined elements added to the array
			return allMeepleLocations.filter(function(n) { return n !== undefined; });
		});
		var meepleGroup = meepleOutlines.enter().append('g').attr({
			class: 'outline-group'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'meeple-outline'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'placed-meeple'
		});
		meepleOutlines.attr({
			transform: function(d) {
				return 'translate(' + (d.meepleOffset.x - 1/2) * tileSize + ',' + (d.meepleOffset.y - 1/2) * tileSize + ')';
			}
		});
		meepleOutlines.select('image.meeple-outline').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) {
				return '/content/images/meeples/outline_' + (d.locationType === 'farm' ? 'lying' : 'standing') +'.png';
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// when an outline is clicked grab the leftmost available meeple and move it onto the outline
			var $placedMeeples = $('.placed-meeple');
			$placedMeeples.attr('visibility', 'hidden');
			$(this).siblings('.placed-meeple').first().removeAttr('visibility');
			// hide the appropriate meeple from the score area
			$('#score-group-' + meepleColor + ' image.' + meeplePlacementMode + '-meeple').first().attr('visibility', 'hidden');
			// hide any placed towers
			$('.placed-tower').attr('visibility', 'hidden');
			delete selectedMove.tower;
			selectedMove.meeple = {
				locationType: d.locationType,
				index: d.index,
				meepleType: meeplePlacementMode
			};
		});
		meepleOutlines.select('image.placed-meeple').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) {
				return '/content/images/meeples/' + meepleColor + '_' + (d.locationType === 'farm' ? 'lying' : 'standing') +'.png';
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// due to a regression in Firefox 34 (https://bugzilla.mozilla.org/show_bug.cgi?id=1119698) these events are firing incorrectly
			// detect event firing on hidden element and redirect the click event manually
			if($(this).attr('visibility') === 'hidden') {
				var event = document.createEvent('SVGEvents');
				event.initEvent('click', true, true);
				d3.select(this.parentNode).select('.meeple-outline').node().dispatchEvent(event);
				return;
			}
			// when a visible meeple is clicked hide it and remove it from the move
			$(this).attr('visibility', 'hidden');
			$('#score-group-' + meepleColor + ' image').removeAttr('visibility');
			delete selectedMove.meeple;
		});
		meepleOutlines.exit().remove();

		// draw outlines indicating the last tile each player placed
		var markers = [];
		var markedPlayers = [];
		// move backwards through the tiles creating a marker for each tile placed (until every player has at least one)
		// for each tile placed assign x and y of the tile and color of the placing player
		var k = gamestate.placedTiles.length - 1;
		while(k > 0 && markedPlayers.length < gamestate.players.length) {
			if(markedPlayers.indexOf(gamestate.placedTiles[k].playerIndex) === -1) {
				markedPlayers.push(gamestate.placedTiles[k].playerIndex);
			}
			markers.push({
				x: gamestate.placedTiles[k].x,
				y: gamestate.placedTiles[k].y,
				color: gamestate.players[gamestate.placedTiles[k].playerIndex].color
			});
			k--;
		}

		var turnMarkers = turnMarkerArea.selectAll('rect.turn-marker').data(markers);
		turnMarkers.enter().append('rect').attr({
			class: 'turn-marker',
			'fill-opacity': 0,
			'stroke-width': 4,
			'stroke-linejoin': 'round',
			rx: 7,
			ry: 7,
			width: tileSize,
			height: tileSize
		});
		turnMarkers.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
			y: function(d) { return svgHeight / 2 + d.y * tileSize; },
			stroke: function(d) { return d.color; }
		});
		turnMarkers.exit().remove();

		// draw the players scores and remaining meeples
		var scoreGroups = scoreArea.selectAll('g.score-group').data(reorderedPlayers);
		var group = scoreGroups.enter().append('g').attr({
			class: 'score-group'
		});
		scoreGroups.attr({
			id: function(d) {
				return 'score-group-' + d.color;
			}
		});
		group.append('text').attr({
			class: 'point-total',
			x: 5 + 7*(tileSize / 4.75),
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'end'
		});
		group.append('text').attr({
			class: 'player-name-outline',
			x: 5,
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'start',
			stroke: 'black',
			'stroke-width': 2.5
		});
		group.append('text').attr({
			class: 'player-name',
			x: 5,
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'start'
		});
		scoreGroups.select('text.point-total').text(function(d) { return d.points; });
		scoreGroups.select('text.player-name-outline').text(function (d) { return d.user.username; });
		scoreGroups.select('text.player-name').attr({
			fill: function(d) {
				if(d.color === 'purple') {
					return 'fuchsia';
				} else if (d.color === 'blue') {
					return 'royalblue';
				}
				return d.color;
			}
		}).text(function (d) { return d.user.username; });
		scoreGroups.exit().remove();

		//TODO: have the active player placed meeple move down from the remaining meeples onto the tile
		var availableMeeples = scoreGroups.selectAll('image.normal-meeple').data(function(d, i) {
			var array = [];
			for(var k = 0; k < d.remainingMeeples; k++) {
				array.push({
					x: 5 + k*(tileSize / 4.75),
					y: tileSize / 4 - 5 + i*(tileSize / 2 - 5),
					url: '/content/images/meeples/' + d.color + '_standing.png',
					row: i
				});
			}
			array.reverse();
			return array;
		});
		availableMeeples.enter().append('image').attr({
			class: 'normal-meeple',
			y: function(d) { return d.y; },
			width: tileSize / 4,
			height: tileSize / 4
		}).on('click', function(d) {
			// if the meeple on the first row is clicked move into normal meeple placement mode
			if(d.row === 0) {
				changeMeepleMode('normal');
			}
			d3.event.stopPropagation();
		});
		availableMeeples.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		availableMeeples.exit().remove();

		var scoreBoardX = 5 + 6*(tileSize / 4.75) + tileSize / 4;

		var largePieceWidth = tileSize * 3 / 8;
		var availableLargeMeeple = scoreGroups.selectAll('image.large-meeple').data(function(d, i) {
			var results = [];
			if(gamestate.expansions.indexOf('inns-and-cathedrals') !== -1) {
				if(d.hasLargeMeeple) {
					results = [{
						x: scoreBoardX,
						y: i*(tileSize / 2 - 5) + tileSize / 14,
						url: '/content/images/meeples/' + d.color + '_standing.png',
						row: i
					}];
				}
				// increment the position indicator if this is the last player we're drawing this for
				if(i === gamestate.players.length - 1) {
					scoreBoardX += largePieceWidth;
				}
			}
			return results;
		});
		availableLargeMeeple.enter().append('image').attr({
			class: 'large-meeple',
			y: function(d) { return d.y; },
			width: largePieceWidth,
			height: largePieceWidth,
			cursor: function(d) {
				return d.row === 0 ? 'pointer' : null;
			}
		}).on('click', function(d) {
			// if the meeple on the first row is clicked move into large meeple placement mode
			if(d.row === 0) {
				changeMeepleMode('large');
			}
			d3.event.stopPropagation();
		});
		availableLargeMeeple.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		availableLargeMeeple.exit().remove();

		var pigMeeple = scoreGroups.selectAll('image.pig-meeple').data(function(d, i) {
			var results = [];
			if(gamestate.expansions.indexOf('traders-and-builders') !== -1) {
				if(d.hasPigMeeple) {
					results = [{
						x: scoreBoardX,
						y: i*(tileSize / 2 - 5) + tileSize / 14,
						url: '/content/images/meeples/' + d.color + '_pig.png',
						row: i
					}];
				}
				// increment the position indicator if this is the last player we're drawing this for
				if(i === gamestate.players.length - 1) {
					scoreBoardX += largePieceWidth;
				}
			}
			return results;
		});
		pigMeeple.enter().append('image').attr({
			class: 'pig-meeple',
			y: function(d) { return d.y; },
			width: largePieceWidth,
			height: largePieceWidth,
			cursor: function(d) {
				return d.row === 0 ? 'pointer' : null;
			}
		}).on('click', function(d) {
			// if the meeple on the first row is clicked move into pig meeple placement mode
			if(d.row === 0) {
				changeMeepleMode('pig');
			}
			d3.event.stopPropagation();
		});
		pigMeeple.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		pigMeeple.exit().remove();

		var builderMeeple = scoreGroups.selectAll('image.builder-meeple').data(function(d, i) {
			var results = [];
			if(gamestate.expansions.indexOf('traders-and-builders') !== -1) {
				if(d.hasBuilderMeeple) {
					results = [{
						x: scoreBoardX,
						y: i*(tileSize / 2 - 5) + tileSize / 14,
						url: '/content/images/meeples/' + d.color + '_builder.png',
						row: i
					}];
				}
				// increment the position indicator if this is the last player we're drawing this for
				if(i === gamestate.players.length - 1) {
					scoreBoardX += largePieceWidth;
				}
			}
			return results;
		});
		builderMeeple.enter().append('image').attr({
			class: 'builder-meeple',
			y: function(d) { return d.y; },
			width: largePieceWidth,
			height: largePieceWidth,
			cursor: function(d) {
				return d.row === 0 ? 'pointer' : null;
			}
		}).on('click', function(d) {
			// if the meeple on the first row is clicked move into builder meeple placement mode
			if(d.row === 0) {
				changeMeepleMode('builder');
			}
			d3.event.stopPropagation();
		});
		builderMeeple.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		builderMeeple.exit().remove();

		var towerMeeples = scoreGroups.selectAll('g.tower-meeple-group').data(function(d, i) {
			var results = [];
			if(gamestate.expansions.indexOf('the-tower') !== -1) {
				if(d.towers > 0) {
					results = [{
						x: scoreBoardX,
						y: i*(tileSize / 2 - 5) + tileSize / 14,
						url: '/content/images/meeples/tower.png',
						row: i,
						count: d.towers
					}];
				}
				// increment the position indicator if this is the last player we're drawing this for
				if(i === gamestate.players.length - 1) {
					scoreBoardX += largePieceWidth;
				}
			}
			return results;
		});
		var towerMeeplesGroup = towerMeeples.enter().append('g').attr({
			class: 'tower-meeple-group'
		});
		towerMeeplesGroup.append('image').attr({
			class: 'tower-meeple',
			y: function(d) { return d.y; },
			width: largePieceWidth,
			height: largePieceWidth,
			'xlink:href': function(d) { return d.url; },
			cursor: function(d) {
				return d.row === 0 ? 'pointer' : null;
			}
		}).on('click', function(d) {
			// if the meeple on the first row is clicked move into tower meeple placement mode
			if(d.row === 0) {
				changeMeepleMode('tower');
			}
			d3.event.stopPropagation();
		});
		towerMeeplesGroup.append('text').attr({
			y: function(d) { return d.y + 7; },
			'text-anchor': 'middle'
		});
		towerMeeples.select('image').attr({
			x: function(d) { return d.x; }
		});
		towerMeeples.select('text').attr({
			x: function(d) { return d.x + largePieceWidth / 2 + 13; }
		}).text(function (d) { return d.count; });
		towerMeeples.exit().remove();

		var goodsTokenScores = scoreGroups.selectAll('g.goods-token-scores').data(function(d, i) {
			var results = [];
			if(gamestate.expansions.indexOf('traders-and-builders') !== -1) {
				results = [{
					url: '/content/images/tokens/fabric_token.png',
					score: d.goods.fabric,
					x: scoreBoardX,
					y: i*(tileSize / 2 - 5) + tileSize / 14
				},{
					url: '/content/images/tokens/wheat_token.png',
					score: d.goods.wheat,
					x: scoreBoardX  + largePieceWidth,
					y: i*(tileSize / 2 - 5) + tileSize / 14
				},{
					url: '/content/images/tokens/wine_token.png',
					score: d.goods.wine,
					x: scoreBoardX + 2 * (largePieceWidth),
					y: i*(tileSize / 2 - 5) + tileSize / 14
				}];
				// increment the position indicator if this is the last player we're drawing this for
				if(i === gamestate.players.length - 1) {
					scoreBoardX += 3 * largePieceWidth;
				}
			}
			return results;
		});
		var goodsTokenScoresGroup = goodsTokenScores.enter().append('g').attr({
			class: 'goods-token-scores'
		});
		goodsTokenScoresGroup.append('image').attr({
			y: function(d) { return d.y; },
			width: largePieceWidth,
			height: largePieceWidth,
			'xlink:href': function(d) { return d.url; }
		});
		goodsTokenScoresGroup.append('text').attr({
			y: function(d) { return d.y + 7; },
			'text-anchor': 'middle'
		});
		goodsTokenScores.select('image').attr({
			x: function(d) { return d.x; }
		});
		goodsTokenScores.select('text').attr({
			x: function(d) { return d.x + largePieceWidth / 2 + 13; }
		}).text(function (d) { return d.score; });
		goodsTokenScores.exit().remove();

		// set the default meeple mode
		changeMeepleMode();

		// resize the score background
		scoreArea.select('#score-bg').attr({
			height: tileSize / 4 + reorderedPlayers.length*(tileSize / 2 - 5),
			width: scoreBoardX + 20, // 15 (amount background shifted left of x axis) + 5 (right margin)
			opacity: .75
		});

		//TODO: show unused tile count, clickable to show remaining tile counts
	}
});
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-50702481-1', 'concarneau.herokuapp.com');
  ga('send', 'pageview');
</script>
</body>
</html>
